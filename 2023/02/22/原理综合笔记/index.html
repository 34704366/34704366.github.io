<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>原理综合笔记 | nccoder</title><meta name="keywords" content="编程技术,linux"><meta name="author" content="王晨昊"><meta name="copyright" content="王晨昊"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机原理综合笔记操作系统 汇编器和编译器的区别 汇编器的输入是汇编语言，作用是将汇编代码转换成机器代码。 编译器通常是将高级语言转换成机器语言。  解释语言和编译语言的区别   强类型和弱类型语言  动态类型和静态类型  javascript是解释性语言么？ 不是，在js初期算是解释型语言，浏览器引擎一般先解释再编译，后来google v8提出了JIT（just in time）编译，JS代码会">
<meta property="og:type" content="article">
<meta property="og:title" content="原理综合笔记">
<meta property="og:url" content="http://example.com/2023/02/22/%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="nccoder">
<meta property="og:description" content="计算机原理综合笔记操作系统 汇编器和编译器的区别 汇编器的输入是汇编语言，作用是将汇编代码转换成机器代码。 编译器通常是将高级语言转换成机器语言。  解释语言和编译语言的区别   强类型和弱类型语言  动态类型和静态类型  javascript是解释性语言么？ 不是，在js初期算是解释型语言，浏览器引擎一般先解释再编译，后来google v8提出了JIT（just in time）编译，JS代码会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.baidu.com/it/u=896707904,4002445675&fm=253&fmt=auto&app=138&f=PNG?w=889&h=500">
<meta property="article:published_time" content="2023-02-22T03:37:20.000Z">
<meta property="article:modified_time" content="2023-08-02T16:01:31.560Z">
<meta property="article:author" content="王晨昊">
<meta property="article:tag" content="编程技术">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.baidu.com/it/u=896707904,4002445675&fm=253&fmt=auto&app=138&f=PNG?w=889&h=500"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/22/%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '原理综合笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-03 00:01:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://gitee.com/jnuwangchenhao"><i class="fa-fw fab fa-github"></i><span> 仓库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">nccoder</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://gitee.com/jnuwangchenhao"><i class="fa-fw fab fa-github"></i><span> 仓库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">原理综合笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-22T03:37:20.000Z" title="发表于 2023-02-22 11:37:20">2023-02-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-02T16:01:31.560Z" title="更新于 2023-08-03 00:01:31">2023-08-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="原理综合笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="计算机原理综合笔记"><a href="#计算机原理综合笔记" class="headerlink" title="计算机原理综合笔记"></a>计算机原理综合笔记</h1><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol>
<li><p>汇编器和编译器的区别</p>
<p>汇编器的输入是汇编语言，作用是将汇编代码转换成机器代码。</p>
<p>编译器通常是将高级语言转换成机器语言。</p>
</li>
<li><p>解释语言和编译语言的区别</p>
<p><img src="%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/compile.png" alt="compile"></p>
</li>
<li><p>强类型和弱类型语言</p>
</li>
<li><p>动态类型和静态类型</p>
</li>
<li><p>javascript是解释性语言么？</p>
<p>不是，在js初期算是解释型语言，浏览器引擎一般先解释再编译，后来google v8提出了JIT（just in time）编译，JS代码会在执行期间直接编译成机器码，不再解释。</p>
</li>
<li><p>MVVM</p>
<p>Model View ViewModel，Model代表数据模型，数据和业务逻辑都在Model层中定义，View代表UI视图，负责数据的展示，ViewModel负责监听Model中数据的改变并且控制视图更新，处理用户交互操作。</p>
<p>M和V是通过VM来联系交互的，M数据改变会通过VM来触发V的刷新，V也由于VM来将逻辑操作的结果传递给M，故实现了M和V的<strong>数据双向绑定</strong>。MVVM开发模式的核心思想就是数据双向绑定。</p>
</li>
</ol>
<ol start="7">
<li><p>浏览器发送url的全过程</p>
<ol>
<li>首先浏览器会判断输入的是请求url还是搜索内容，如果是url的话会提取出其中的host和请求参数</li>
<li>检查是否有本地缓存，如果没有的话就会调用系统调用来发送网络请求</li>
<li>如果是域名，查询DNS，将域名转换为ip</li>
<li>浏览器中有一个专门用于网络请求的线程，会自动创建好header body等信息组装成报文，然后建立TCP连接，再传输</li>
<li>收到response之后有可能会重定向，网络worker会从响应头里面取出对应的地址，再发送新的请求</li>
<li>再收到请求之后没有问题的话，检查一下收到的文件是什么类型，比如如果是html页面的话，content-type为text/html，</li>
<li>然后渲染worker开始执行渲染工作<ol>
<li>浏览器接收到server返回的数据以后，首先解析html源文件，生成DOM树，解析CSS，生成CSSOM树。</li>
<li>将DOM树和CSSOM树结合，生成渲染树（render tree）</li>
<li>开始执行JS代码，结合JS生成布局树（layout树），先重排（回流）（得到节点的几何信息：位置，大小等），再重绘（根据渲染树以及回流得到的几何信息，展示外观等）</li>
<li>JS代码在生成render tree之后，就会执行，途中假如JS代码修改了DOM，会先挂起JS<strong>（defer等机制是否会影响这个流程）</strong>，首先更新DOM，这个过程会导致render tree和layout tree的修改，比较耗时，涉及到重排和重绘。（具体重排重绘）layout tree更新完之后会通知浏览器的UI线程，进行重绘<strong>（重绘不一定导致重排,但重排一定会导致重绘）</strong>。完成之后再继续JS</li>
</ol>
</li>
</ol>
</li>
<li><p>HTTP</p>
<ol>
<li>状态码</li>
<li>头部字段</li>
<li></li>
</ol>
</li>
<li><p>网络攻击</p>
<ol>
<li><p>CSRF（Cross Site Request Forgery，跨站域请求伪造）</p>
<p>本质是盗用用户的cookie信息来伪装成授权用户。（在早期浏览器中是否携带cookie和当前站点无关，只和目的地有关）</p>
<h6 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h6><ul>
<li>验证HTTP Referer值（请求的来源），但是不是绝对安全，referer值是第三方保障，基于浏览器的，有可能被篡改</li>
<li>token</li>
</ul>
</li>
<li><p>XSS</p>
<p>XSS是跨站脚本攻击，比如在输入框内输入一些恶意脚本想让其在服务器上运行</p>
<p>分为：存储型、反射性、DOM型</p>
<h6 id="存储型："><a href="#存储型：" class="headerlink" title="存储型："></a>存储型：</h6><ul>
<li>攻击者将恶意代码提交到目标网站的数据库中</li>
<li>用户打开目标网站的时候，网站服务器把恶意代码取出来发给了服务端</li>
<li>服务端执行了恶意代码</li>
<li>恶意代码窃取了用户的数据并发送到了攻击者的网站</li>
</ul>
<h6 id="反射型："><a href="#反射型：" class="headerlink" title="反射型："></a>反射型：</h6><ul>
<li>与存储型XSS区别是恶意代码放在了URL中，常见于通过URL传递参数的功能，比如网站搜索、跳转等</li>
</ul>
<h6 id="DOM型："><a href="#DOM型：" class="headerlink" title="DOM型："></a>DOM型：</h6><ul>
<li>与前两种区别是本身是由于浏览器安全漏洞（比如在dom内嵌入一个恶意script）</li>
</ul>
<h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h6><ul>
<li>导致XSS根本原因就是没有对用户输入的内容进行过滤防范，最主要的防御措施就是对用户输入的不合法的参数进行排除，比如<code>&lt;script&gt;</code>标签就可以直接过滤掉，或者编码存储</li>
<li>cookie设置HttpOnly，这样从浏览器document中就无法获取cookie，可以保证cookie不会因为XSS攻击而被获取到</li>
<li>限制加载其他域的资源文件，禁止向第三方域提交数据，禁止执行内联脚本和未授权的脚本等</li>
</ul>
</li>
<li><p>asd</p>
</li>
</ol>
</li>
<li><p>首页白屏有可能是什么现象导致的，如何调试？</p>
<ol>
<li>先检查是不是网络的问题，浏览器控制台中查看一下报了什么错误，如果有报错，处理对应的内容</li>
<li>如果没有报错，抓包看一下网络请求是否正常收到了，收到的数据是不是正常的，是不是JS脚本或CSS阻塞了页面渲染</li>
<li>查看一下前端代码中有没有隐性bug，比如路由权限跳转中没有权限是不是正常跳到404或者登录页，代码不兼容当前浏览器</li>
</ol>
</li>
<li><p>Web应用首屏加载优化思路</p>
<p>白屏的时候，主要是浏览器执行<strong>下载HTML/CSS/JS、生成CSSOM、执行js代码、生成布局树、绘制页面</strong>等一系列操作，优化都是针对这几个任务展开的</p>
<ol>
<li><p>分析首屏加载过慢的原因</p>
<ul>
<li>页面资源是否太多 / 资源文件太大</li>
<li>资源是否重复发送请求去加载</li>
<li>网络环境问题</li>
<li>加载脚本的时候，渲染内容堵塞了</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>减小入口文件积</p>
<p>​    动态加载路由，在Webpack中设置让代码分包，通过<code>splitChunksPlugin</code>插件让暂时不用的模块和第三方依赖分开加载，对HTML页面进行代码压缩</p>
</li>
<li><p>静态资源本地缓存</p>
<p>​    设置HTTP缓存 / 采用<code>Service Worker</code>离线缓存</p>
</li>
<li><p>可以将一些不需要在解析HTML阶段使用的JavaScript标记上sync或者defer（sync和defer都是非阻塞的下载，sync在下载完之后马上执行（不保证执行顺序），defer在文档解析完毕之后执行（保证执行顺序））</p>
</li>
<li><p>UI框架按需加载</p>
<p>生产环境中避免引入UI框架全部组件，按需引入</p>
</li>
<li><p>图片资源的压缩</p>
<p>sprite images / svg-icon</p>
</li>
<li><p>开启GZip压缩</p>
</li>
<li><p>避免组件重复打包，提取公共模块</p>
<p>在webpack打包中，修改<code>CommonsChunkPlugin</code>的配置，设置minChuncks: n ,表示会把被引用n次及以上的包单独抽离出来放入公共依赖文件，避免了重复加载组件。vite中。。。</p>
</li>
<li><p>使用SSR（server side render|服务端渲染），例如nuxt.js就是一个开发SSR应用的再次封装vue.js框架</p>
</li>
<li><p>预渲染，可以先返回一个整个的页面骨架，Layout</p>
</li>
</ul>
</li>
</ol>
<p><img src="%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/4fafe900-3acc-11eb-85f6-6fac77c0c9b3.png" alt="详情图"></p>
</li>
<li><p>前端如何优化网站性能</p>
<p><strong>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</strong>。交互阶段的重排和回流，js执行阶段</p>
<ol>
<li><p>减少http请求数量</p>
</li>
<li><p>控制合理的资源文件加载优先级  </p>
<p>（涉及defer等标签属性的作用）</p>
</li>
<li><p>多用浏览器缓存</p>
</li>
<li><p>重排和回流</p>
</li>
<li><p>减少DOM操作</p>
</li>
<li><p>资源懒加载</p>
</li>
<li><p>监听事件是否能用事件委托完成（foucs、blur等事件没有冒泡机制就不能绑定事件委托）</p>
</li>
<li><p>mousemove/out等事件是不断通过位置去计算定位，对性能消耗较高，尽量避免使用</p>
</li>
</ol>
</li>
<li><p>网页从输入网址到渲染完成经历了哪些过程</p>
<ol>
<li>输入网址以后，浏览器首先对URL进行解析，通过URL确定发送请求的协议，域名，文件地址以及是否所带path或query参数（还有具体是怎么解析path和query的）</li>
<li>打包生成HTTP/HTTPS请求包</li>
<li>查询DNS服务器，找到域名对应的真实IP地址，首先查本地的缓存表，没有的话就问根域名服务器，DNS查询是层级搜索的，一层一层向下查找。</li>
<li>浏览器请求系统调用（调用socket库），让操作系统来发送请求</li>
<li>网络传输过程中涉及到应用层HTTP（如果是quic协议，是基于udp），传输层TCP，网络层IP，以及链路层和物理层的传输以及接收。</li>
<li>浏览器渲染前端页面：<ol>
<li>浏览器接收到server返回的数据以后，首先解析html源文件，生成DOM树，解析CSS，生成CSSOM树。</li>
<li>将DOM树和CSSOM树结合，生成渲染树（render tree）</li>
<li>开始执行JS代码，结合JS生成布局树（layout树），先重排（回流）（得到节点的几何信息：位置，大小等），再重绘（根据渲染树以及回流得到的几何信息，展示外观等）</li>
<li>JS代码在生成render tree之后，就会执行，途中假如JS代码修改了DOM，会先挂起JS<strong>（defer等机制是否会影响这个流程）</strong>，首先更新DOM，这个过程会导致render tree和layout tree的修改，比较耗时，涉及到重排和重绘。（具体重排重绘）layout tree更新完之后会通知浏览器的UI线程，进行重绘<strong>（重绘不一定导致重排,但重排一定会导致重绘）</strong>。完成之后再继续JS</li>
</ol>
</li>
</ol>
</li>
<li><p>Vue生命周期过程</p>
<p>在vue中实例从创建到销毁的一系列过程就是生命周期，大致有：创建、初始化数据、编译模板、挂载DOM、渲染、销毁等。（这里涉及到生命周期钩子函数中会自动绑定this到实例中，可以访问this.data和this.methods，这样就意味着不能用箭头函数来定义生命周期方法）</p>
<p>Vue生命周期总共可以分为8个阶段：<strong>创建(create)前后, 载入(mount)前后,更新(update)前后,销毁(destory)前后</strong>。以及特殊的activated：keep-alive缓存的组件激活时，deactivated：keep-alive 缓存的组件停用时调用，errorCaptured：捕获一个来自子组件的错误被停用的时候</p>
<h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><table>
<thead>
<tr>
<th align="left">生命周期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">执行时组件实例还未创建，通常用于插件开发中执行一些<strong>初始化任务</strong></td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">组件初始化完毕，各种<strong>数据可以使用</strong>，常用于异步数据获取</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">未执行渲染、更新，dom未创建</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">初始化结束，dom已创建，可用于获取访问<strong>数据和dom元素</strong></td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">更新前，可用于获取更新前各种状态</td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">更新后，所有状态已是最新</td>
</tr>
<tr>
<td align="left">beforeDestroy（beforeUnmount）</td>
<td align="left">销毁前，可用于一些<strong>定时器或订阅的取消</strong></td>
</tr>
<tr>
<td align="left">unmounted</td>
<td align="left">组件已销毁，作用同上</td>
</tr>
</tbody></table>
</li>
<li><p>前端模块化的发展过程</p>
<ol>
<li><p>script标签引入，模块之间的关系混乱，项目一旦变大维护起来相当麻烦。</p>
</li>
<li><p>模块化，用一个入口js文件来将其余用到的模块通过代码控制起来，按需加载到当前模块中。<code>CommonJS</code>、<code>ES Modules</code></p>
</li>
<li><p>现代化打工工具Webpack、Vite、Rollup、Trubopack</p>
<p>解决的问题：</p>
<ol>
<li>统一管理模块化JS、HTML、CSS以及其他静态资源，包括自动分包等</li>
<li>现代开发中需要用到Babel、ESlint等工具，编写CSS样式的less、sass等预处理器、TypeScript规范等工具，<strong>统一管理</strong></li>
<li>开发阶段实现了<strong>热重载</strong>，方便调试</li>
<li>帮助程序员完成代码压缩、合并和其他相关的<strong>优化</strong>。</li>
</ol>
</li>
</ol>
</li>
<li><p>Webpack打包流程</p>
<ol>
<li>首先初始化流程，从配置文件和Shell语句中<strong>读取和合并参数</strong>，初始化需要使用的插件和配置插件等执行环境所需要的参数。</li>
<li>编译构建流程：从entry（入口文件）出发，针对每个Module（一个文件就是一个Module）串行调用对应的<strong>Loader去处理对应的文件</strong>，再找到该Module依赖的其他Module，<strong>递归的进行编译处理</strong> ，涉及到make、build、seal、emit</li>
<li>输出流程，对编译后的Module<strong>组合成Chunk</strong>，把Chunk<strong>转换成文件</strong>，输出到文件系统</li>
</ol>
</li>
<li><p>Webpack常用的loader</p>
<ul>
<li>less-loader、sass-loader、postcss-loader</li>
<li>html-minify-loader：压缩HTML</li>
<li>babel-loader</li>
<li>TypeScript转成JavaScript</li>
<li>css-loader。分析css模块之间的关系，并合并成一个css</li>
</ul>
</li>
<li><p>Webpack plugin</p>
<p>目的是为了解决loader无法实现的事情，loader只是一个转换函数，loader只运行在打包文件之前，而plugins可以运行在整个编译周期。</p>
<p>比如在编译打包完成之后，我们想对文件目录结构再进行一些调整，就只能用plugin</p>
<p>常见plugin：MinChunkSizePlugin，确保chunk大小超过指定限制。</p>
<p>mini-css-extract-plugin：提取CSS到一个单独的文件中</p>
<p>clean-webpack-plugin：每次打包的时候清空<code>/dist</code>目录</p>
</li>
<li><p>Webpack 模块热更新（HMR）原理</p>
<p>项目运行时候，在浏览器中会维护运行一个HMR runtime，在webpack dev server中会有一个HMR server这样一个模块，这个模块和浏览器中的那个建立一个websocket连接，在模块有更新的时候，编译器（compiler）将更新的内容传递给webpack dev server中的HMR server，然后HMR server通过ws连接，将更新的内容传递给浏览器中的HMR runtime，HMR runtime再将内容替换到真正的代码中</p>
</li>
<li><p>优化webpack打包速度</p>
<ul>
<li>用alias别名，以减少相对路径的查询</li>
<li>使用cache-loader，将结果混村到磁盘中，显著提升二次构建的速度</li>
<li>sourceMap可以选一些信息不那么详细的</li>
</ul>
</li>
<li><p>sourceMap都有哪些</p>
<ul>
<li>eval</li>
<li>cheap-eval-source-map</li>
<li>cheap-module-eval-source-map</li>
</ul>
</li>
<li><p>防止XSS攻击</p>
</li>
<li><p>对称加密/非对称加密</p>
</li>
<li><p>http / https</p>
</li>
<li><p>https中间人攻击</p>
</li>
<li><p>前端事件流</p>
</li>
<li><p>函数柯里化</p>
</li>
<li><p>SSR</p>
<p>优点：便于做SEO，可以优化首屏加载时间。缺点：不利于前后端解耦，会加大服务器的压力</p>
<p>二者本质的区别是，是server还是client来生成DOM树。</p>
<p>分别使用场景：</p>
<p>​        CSR：管理后台等交互逻辑强，不需要SEO，对性能要求不很高的情况</p>
<p>​        SSR：企业级网站、电商平台等用于页面展示，交互不算复杂，需要SEO的情况</p>
</li>
<li><p>页面权限控制</p>
<p>1. </p>
</li>
<li><p>获取页面url方法</p>
<ul>
<li>window.location.href</li>
</ul>
</li>
<li><p>跨域问题</p>
<p> 浏览器基于同源策略的一种安全手段，协议相同、主机相同（host）、端口相同(port)，只要三者有一个不相同，就会产生跨域问题（并不是收不到response，用抓包工具可以看到返回的数据，只是浏览器限制获取不到数据）</p>
<p> 解决方案：</p>
<ol>
<li>CORS(Cross-Origin Resource Sharing，跨域资源共享)是一个系统，由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端js代码获取跨域请求的响应，配置过程是增加一些HTTP头，需要server配合实现</li>
<li>代理(Proxy)也称网络代理，用本地的服务来代理获取跨域的请求再返还给client，webpack和vite都有这个功能可以配置，还可以通过配置nginx来实现代理。</li>
<li>JSONP（JSON with Padding），原理是创建一个script标签，利用script标签的src属性不受同源策略限制这一特性，来请求跨域的server上的数据</li>
</ol>
</li>
<li><p>vue中hash模式和history模式以及abstract模式</p>
</li>
<li><p>前端项目中是怎么排错的</p>
<ol>
<li>考虑后端接口错误，axios的拦截器筛选出后端接口返回的http状态码和业务状态码出错的情况</li>
<li>代码逻辑问题<ol>
<li>全局设置错误处理 <code>Vue.config.errorHandler</code>函数来处理未捕获错误的处理函数。（vue@2.*中不同版本处理的情况不同）（vue出错的过程先检查出错的地方有没有catch然后向祖先节点依次查找，最后如果没有才到globalHandleError）</li>
<li><code>errorCaptured</code> vue2.5提出的生命周期钩子函数，捕获到一个来自子孙组件的错误的时候会被调用</li>
<li>结合错误看源码分析，举例：</li>
</ol>
</li>
</ol>
</li>
<li><p>tree shaking</p>
<ol>
<li><p>为什么需要tree shaking</p>
<p>是因为JS动态语言的特性</p>
</li>
<li><p>tree shaking原理</p>
<p>涉及到ES6 modules和CommonJS的部分区别（ES6 modules相比CommonJS有很多额外的限制），注意export named要比export default的tree shaking效果好：</p>
<ul>
<li>module必须要在最顶层被import</li>
<li>mudule内部自动被定义为strict mode</li>
<li>module name不能动态改变</li>
</ul>
</li>
</ol>
</li>
<li><p>什么是innerHTML</p>
</li>
<li><p>Promise</p>
<p>​        Promise怎么解决嵌套回调问题：首先嵌套回调问题是由于在执行一个任务的时候带上回调函数，等待任务处理结束之后，再执行回调函数中的处理，而Promise实现了回调函数的延迟绑定，在Promise定义中不需要带上具体的回调函数，内部定义中等到任务执行完毕之后就调用<code>resolve()</code>函数，而在实际调用Promise实例的时候，才在<code>.then()</code>中指定具体的回调函数操作。</p>
</li>
<li><p>Generator</p>
<p> Generator本质上来说是协程的应用，定义的时候协程通过yield来主动交出线程的控制权（从表现上来说就是暂停该函数的运行，当调用者执行<code>.next()</code>方法的时候才会恢复执行），通过return来关闭当前协程。</p>
<p> <code>async/await</code>关键字就是对Generator和Promise结合使用的一种语法糖，用async关键字定义的函数就是一个Generator函数，</p>
<p> <code>await</code>关键字实际上暂停当前协程的执行，将当前线程的控制权转交给父协程执行，同时返回一个Promise对象（这个Promise对象中的<code>.then()</code>是父协程自动调用的）,await后面如果跟着一个Promise对象，那么会自动执行这个Promise对象以及它的.then()</p>
</li>
<li><p>JS编译/解释 过程</p>
<ol>
<li>首先是词法分析，将源代码转成一个个的token</li>
<li>对token进行语法分析，将token转为AST</li>
</ol>
</li>
<li><p>ES6 类的底层原理</p>
<p>ES6的class实际上还是通过原型链的继承方法，是一种寄生继承的方式，在构造器中根据父类（如果没有声明继承谁那默认继承Object）创建一个对象，然后经过构造器中的操作为这个对象添加属性和方法，把<code>__proto__</code>指向父类构造函数的<code>prototype</code></p>
</li>
<li><p>和ES5实现类的区别</p>
<ol>
<li>最大的区别是ES5继承本质上是先<strong>创建子类的实例对象</strong>，给对象上添加上父类的方法和属性，再让对象的原型指向父类的构造函数。ES6中更像Java等传统的面向对象语言，先创建一个<strong>父类的实x例对象</strong>（调用super()），然后通过子类中的定义来添加一些属性或者方法到这个实例对象上面。</li>
<li>ES5中写一个构造函数本质上就是一个普通函数，调用的时候不用new也行，不过就是不能正常的返回生成的实例。ES6中做了判断，如果不是用new关键字调用的就会报错</li>
<li>变量提升：ES6 class的实现并没有变量提升，就类似于let 和 var的区别</li>
<li>class里面可以直接用static关键字写静态函数，es5里面是写到构造函数上。</li>
</ol>
</li>
<li><p>为什么null被误判成Object类型</p>
<p>null属于一个基本类型Null，而不是Object，<strong>typeof</strong>之所以会判定为<strong>Object</strong>类型，是因为JS数据类型在底层都是以一个二进制数来存储的，<strong>Object的前三位为0</strong>，而null的二进制数是全0表示的，所以恰好被误判为Object类型。可以用instanceof来判断，它不会将null视为Object的实例</p>
</li>
<li><p>delete</p>
<p>delete是用来删除一个对象的属性</p>
<ul>
<li>不能删除<strong>原型链</strong>上的属性</li>
<li>不能删除描述符中<strong>configurable</strong>为false的属性</li>
<li>删除数组中元素的时候，<strong>length不会随之减小</strong>，对应位置元素变成undefined</li>
</ul>
</li>
<li><p>new关键字原理</p>
<ol>
<li>首先创造一个对象，根据构造器通过原型链连接起来（新对象的<code>__proto__</code>指向构造器的<code>prototype</code>）</li>
<li>将this绑定到新建的对象上</li>
<li>进行新对象的属性赋值和其他代码运行</li>
<li>判断返回类型是不是对象（node报错），如果没有return或者返回一个基本类型变量，那么忽略<strong>直接返回this</strong>，如果返回值是引用类型变量那么就返回该值（包括数组，对象，函数等）</li>
</ol>
</li>
<li><p>详细说var let const</p>
<p> ES5之前都是用var来声明变量，let和const是为了解决var存在的一些问题，</p>
<ol>
<li><p>首先是存在<strong>变量声明提升</strong>的情况，在代码逻辑复杂的情况下不便于调试容易出bug。变量提升：例如声明<code>var a = 10;</code>实际上会在本代码段的最开始先声明<code>var a</code>;然后在执行在该行再赋值，这中间如果有人访问了a，那么就是<code>undefined</code>。</p>
<p>（注意let具有<strong>暂时性死区</strong>特性，如果在一个代码块中let声明一个变量，那么声明之前是无法访问到同名的父作用域级的变量）</p>
</li>
<li><p>var可以对一个变量<strong>重复声明</strong>，let和const不可以</p>
</li>
<li><p>var在全局作用域下声明一个变量，那么这个<strong>变量属于window或者global</strong>，let和const不是</p>
</li>
<li><p>var除非在函数中声明，否则是<strong>全局作用域</strong>的（ES5本身也这么设计，只有全局作用域和函数作用域，没有<strong>块级作用域</strong>），let声明的变量只在当前代码段有效（注意for循环中循环定义部分和循环体部分不是同一个作用域，是父子关系）</p>
</li>
</ol>
<p> const是声明一个常量，声明的时候必须赋值否则报错，其他特性和let相同。注意并不保证其指向的对象的内容不发生改变，只是一个不可变的引用。</p>
</li>
<li><p>深拷贝</p>
<ul>
<li><code>JSON.parse(JOSN.stringify(obj))</code>，缺点是不能完全实现，函数不能通过这种方式拷贝，描述符中不可枚举的属性不能被拷贝、循环引用不能拷贝</li>
<li>实际项目中直接用lodash库的deepClone</li>
<li>自己手写实现的话，要考虑很多情况、描述符、Date、Regex、null / undefined、Array等</li>
</ul>
</li>
<li><p>js中的异步方案</p>
<ol>
<li>回调函数</li>
<li>Promise对象</li>
<li>generator函数</li>
<li>async/await （本质上还是generator函数）</li>
</ol>
</li>
<li><p>闭包</p>
<p> ​        闭包表现上来说是：一个函数返回一个内部的函数，通常是内部函数来引用这个外部函数定义的局部变量。然后这个局部变量不会被GC回收，会一直存在内存中，但是从别的地方访问不到，只有通过这个被返回的内部函数才能访问的到，以此来实现创建私有变量和延长变量的生命周期等。一般来说除非有特定需要，尽量避免使用（避免在无意间使用），因为在函数中创建函数会增大处理开销。</p>
<p> ​        闭包并不会在call stack调用栈中保存函数上下文，而是会将闭包内引用的变量生成一个新的作用域(Closure)作用域，介于当前作用域和上层作用域之间。</p>
<p> ​        例子：防抖可以用闭包做，延迟调用(setTimeout)， 还可以做一个只执行一次某逻辑的函数（配合闭包实现的私有变量（vue computed）。</p>
</li>
<li><p>this</p>
<p>this是和执行上下文绑定的（和作用域链和词法作用域是两种不同的东西），this是为了访问对象的内部的属性，和调用它的环境是相关的，如果其执行上下文是在全局上下文，那么就指向window（node里面是global）</p>
</li>
<li><p>函数执行上下文的生命周期</p>
<ol>
<li><p>创建阶段：当函数被调用，但是没有执行内部代码之前</p>
<ol>
<li>确定this的指向</li>
<li>确定词法环境和变量环境（可以理解成确定作用域），创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中（这一步var会导致变量提升）</li>
</ol>
</li>
<li><p>执行阶段：执行变量赋值、代码执行</p>
</li>
<li><p>回收阶段，等待虚拟机回收执行上下文，包括内存清理等。</p>
</li>
</ol>
</li>
<li><p>浏览器页面之间通信的方式</p>
<ul>
<li>storage</li>
</ul>
</li>
</ol>
<ul>
<li>创建MessageChannel实例，通过postMessage来通信（支持跨域，在页面中传输数据）<ul>
<li>SharedWorker</li>
</ul>
</li>
</ul>
<ol start="31">
<li><p>JS为什么被设计为单线程</p>
<p>JS从设计之初，就是为了作为浏览器的脚本语言，实现用户和浏览器的交互，其中重要的操作DOM，如果他是多线程的，会带来很多复杂的同步问题，得不偿失，单线程的JS由于其事件循环机制，应对浏览器这种通常高I/O的场景，性能已经足够优秀。</p>
</li>
<li><p>浏览器的合成是什么</p>
<p> 一张网页时由很多个图片叠加在一起组成的，每个图片对应一个图层，在这个过程中，将素材分解成多个图层的操作就是<strong>分层</strong>，最后将这些图层合并到一起的操作称为<strong>合成</strong>，合成操作是运行在<strong>合成线程</strong>上面的，也就是说不会影响到主线程的执行（有时候主线程卡住了，但是CSS动画依然能够执行）。</p>
</li>
<li><p>web和客户端的区别</p>
<ul>
<li>客户端有更好的<strong>离线使用能力</strong>和<strong>消息推送能力</strong>，web端对应的解决方案是用service worker来解决离线存储和消息推送的问题</li>
<li>web应用缺少以从桌面开始的一级入口，可解决方案是引入<code>manifest.json</code>来解决</li>
</ul>
</li>
<li><p>Shadow DOM</p>
<p>Shadow DOM就是一个封装隔离的DOM树组件，内部的CSS属性是隔离开的不用担心与其他组件相互影响，通常是用template来创建，内部的JS属性可以供外部使用，因为JS本身组件化支持良好</p>
<p>可以通过<code>Element.attachShadow()</code>来创建</p>
</li>
<li><p>浏览器事件循环</p>
<p>因为js是单线程的语言，同一时刻只能执行一件事，但是内部有同步异步机制来处理堵塞问题。通过事件循环机制来实现异步。</p>
<p>代码执行到同步代码的时候会顺序依次执行，遇到异步任务就把他假如到事件循环队列中。</p>
<p>其中异步任务还细分为宏任务和微任务，微任务有：</p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Proxy对象</li>
<li>process.nextTick（Node.js）</li>
</ul>
<p>宏任务有：</p>
<ul>
<li>script 标签引入的代码(可以理解为外层同步代码)</li>
<li>setTimeout/setInterval</li>
<li>UI rendering/UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I/O（Node.js）</li>
</ul>
<p>微任务在异步队列中是优先执行的，每次一个宏任务执行完毕之后都会检查微任务队列中是否有任务，如果有的话优先执行微任务队列。（await的原理就是加入微任务队列）</p>
</li>
<li><p>浏览器安全沙箱</p>
<p>本质上就是为了保护浏览器的安全而设计的，让渲染进程和浏览器内核进程隔离开，比如一个网络请求，需要<strong>浏览器内核</strong>进程去真正访问网络（<strong>跨域请求等</strong>也是在这一步完成的），然后将资源通过IPC（进程间通信）交给渲染进程，由渲染进程去渲染页面渲染资源，然后再将结果交给浏览器内核进程来真正显示在浏览器上。目的是为了让<strong>渲染进程不能访问系统资源</strong>，需要调用或者访问系统资源的时候，通过IPC来让浏览器内核进程操作。</p>
</li>
<li><p>浏览上下文组（browsing context group）</p>
<p>浏览上下文包括一个标签页的<strong>历史记录</strong>、<strong>window对象</strong>以及<strong>滚动条位置信息</strong>等等。</p>
<p>如果标签页a和b符合两种打开方式，1.a通过window.open()来打开标签页b。2.a中的href链接的方式来打开标签页b，符合任意一个的话，就称为标签页a和标签页b是有连接的，他们属于同一个浏览上下文组，这时候它们是由同一个渲染进程来渲染的</p>
</li>
<li><p>Node事件循环</p>
<p>Node的事件循环分成了六个阶段，分别是</p>
<ul>
<li> timers阶段（setTimeout、setInterval回调）</li>
<li>I/O事件回调阶段</li>
<li>idle，prepare 限制阶段，仅系统内部使用</li>
<li>poll 轮询阶段，检索新的I/O事件，并执行与I/O相关的回调</li>
<li>check检查阶段，setImmediate()回调函数在这里执行</li>
<li>close 关闭事件回调阶段，例如socket.on(‘close’, …)</li>
</ul>
<p>每个阶段都是一个状态，Node会依次检查这些阶段执行其回调函数，每个阶段的最大执行次数和优先级都不同。</p>
</li>
<li><p>原型链式继承和构造函数继承的区别</p>
<ul>
<li>原型链式继承本质是先创建一个父类的实例，然后创建子类实例的时候将子类实例的原型指向父类实例，并将子类构造函数的原型指向父类构造函数，如果用这个方式创建多个子类，由于共享父类实例的属性，如果这个属性有引用类型，那么就会出现共同引用的现象。</li>
<li>构造函数继承本质是在子类 构造函数中使用call或者apply在this中调用父类构造函数，其实就是相当于复制了以下父类构造函数的操作</li>
<li>组合式继承就是结合上面两种</li>
</ul>
</li>
<li><p>js调用栈(call stack)</p>
<p>调用栈是管来函数调用关系的一种数据结构，在函数调用的时候，会把函数的执行上下文push到栈中，return之后会把它从栈中pop出。调用栈是有大小限制的，也就是函数调用深度如果太深会报栈溢出的错误</p>
</li>
<li><p>js词法作用域</p>
<p>词法作用域是在代码编写的时候就确定好的，和通过this取值不同。和作用域链的区别是：词法作用域只关联自己引用到的那些变量。</p>
</li>
<li><p>内存泄露的常见情况</p>
<ul>
<li>意外的全局变量（var）</li>
<li>闭包</li>
<li>未被清空的定时器</li>
<li>未被销毁的不用的事件监听器</li>
<li>DOM引用</li>
</ul>
</li>
<li><p>google v8垃圾回收的几种方式</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>标记清除法</td>
<td>实现简单，容易和其他算法组合</td>
<td>1.碎片化2.速度不理想，每次都要遍历空闲列表找到足够大的分块 3. 和写时复制技术不兼容（在活动对象上打标记）</td>
</tr>
<tr>
<td>标记压缩法</td>
<td>有效利用了堆，不会出现内存碎片</td>
<td>压缩过程的开销大，需要多次搜索堆</td>
</tr>
<tr>
<td>引用计数法</td>
<td>可即刻回收垃圾，最大暂停时间短，不需要沿着指针查找</td>
<td>1.循环引用无法回收2.赋值操作都要替换成引用更新3.计数器计算开销和空间开销</td>
</tr>
<tr>
<td>GC复制法</td>
<td>吞吐量高，只需要关心活动对象，无碎片，无额外链表开销分配迅速</td>
<td>1.堆使用率低2.与保守式GC不兼容3.递归调用函数，复制子对象需要递归复制函数消耗栈空间</td>
</tr>
<tr>
<td>分代回收</td>
<td>原理是不活跃的对象尽量少检测，实际使用中回收消耗时间减少</td>
<td>不适用于所有情况，如果新生代对象活跃时间很长则效果适得其反</td>
</tr>
<tr>
<td>保守式GC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>增量式GC</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>常见的内存泄露的情况</p>
<ol>
<li>意外定义的全局变量，比如在一个函数中定义了全局变量，但是这个变量没有用</li>
<li>用闭包来维持函数内部的局部变量</li>
<li>原生编程中没有清理对DOM的引用</li>
</ol>
</li>
<li><p>html和js加载顺序，冲突会怎么样</p>
</li>
<li><p>js的本地缓存</p>
<ol>
<li><p>cookie，一般是网站为了辨别用户身份而存储在终端上的数据，目的是为了解决HTTP无状态，有大小限制不超过4kb，键值对的形式存储（还有一些控制信息，如过期时间，域名，需要带cookie才能访问的路径等）。cookie一般每次请求中都被发送，这时就很有必要用HTTPS协议传输信息</p>
</li>
<li><p>localStorage</p>
<ul>
<li>H5新方法，IE8及以上兼容，localStorage是持久化存储的，除非主动删除，否则数据永远不过期</li>
<li>同一个域（主机 端口 协议）中的共享的</li>
<li>大小跟浏览器具体设置有关系，微信小程序10M，chrome 5m</li>
<li>受同源策略的影响</li>
<li>无法像Cookie一样设置过期时间，只能存字符串</li>
</ul>
</li>
<li><p>sessionStorage</p>
<ul>
<li>不是持久化存储，如果关闭页面的话会导致sessionStorage丢失。</li>
</ul>
</li>
<li><p>IndexDB</p>
<p>存储量理论上没有上限，数据量大的话比LocalStorage操作性能高，可以支持JS的对象存储</p>
<p>操作繁琐</p>
</li>
</ol>
</li>
<li><p>link和@import的区别</p>
<ul>
<li>引入内容不同：link除了引用样式文件，还可以引用图片等资源文件，@import只引用样式文件</li>
<li>加载顺序不同：link在页面载入时候同时加载，@import在页面完全载入以后加载</li>
<li>link无兼容性问题</li>
<li>link支持js控制DOM去改变样式，@import不支持</li>
</ul>
</li>
<li><p>CSS3新增的选择器</p>
<ul>
<li>层次选择器（p~ul），选择前面有p元素的每个ul元素</li>
<li>伪类选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first</span>-of-type 表示一组同级元素中其类型的第一个元素</span><br><span class="line"><span class="selector-pseudo">:last-of-type</span> 表示一组同级元素中其类型的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:only-of-type</span> 表示没有同类型兄弟元素的元素</span><br><span class="line"><span class="selector-pseudo">:only-child</span> 表示没有任何兄弟的元素</span><br><span class="line"><span class="selector-pseudo">:nth-child</span>(n) 根据元素在一组同级中的位置匹配元素</span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type</span>(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数</span><br><span class="line"><span class="selector-pseudo">:last-child</span> 表示一组兄弟元素中的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:root</span> 设置<span class="selector-tag">HTML</span>文档</span><br><span class="line"><span class="selector-pseudo">:empty</span> 指定空的元素</span><br><span class="line"><span class="selector-pseudo">:enabled</span> 选择可用元素</span><br><span class="line"><span class="selector-pseudo">:disabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:checked</span> 选择选中的元素</span><br><span class="line"><span class="selector-pseudo">:not</span>(selector) 选择与 &lt;selector&gt; 不匹配的所有元素</span><br></pre></td></tr></table></figure>

<ul>
<li>属性选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute*=value]</span>：选择attribute属性值包含value的所有元素</span><br><span class="line"><span class="selector-attr">[attribute^=value]</span>：选择attribute属性开头为value的所有元素</span><br><span class="line"><span class="selector-attr">[attribute$=value]</span>：选择attribute属性结尾为value的所有元素</span><br></pre></td></tr></table></figure></li>
<li><p>判断元素在页面上是否还可见</p>
<ol>
<li>offset上边框到上内边框之间的像素距离，scrollTop滚动视窗的高度距离window顶部的距离，随着往上滚动而不断增加，<code>return (offset - scrollTop) &gt;= viewPortHeight </code></li>
<li>getBoundingClientRect函数，返回DOMRect对象，如果还在视窗内的话，top大于0，left大于0，bottom小于视窗高度，right小于视窗宽度</li>
<li>Intersection Observer，判断当前元素和父级元素是否重合</li>
</ol>
</li>
<li><p>判断元素触底</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollTop + clientHeight &gt;= scrollHeight</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</p>
</li>
<li><p><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度</p>
</li>
<li><p><code>scrollHeight</code>表示body所有元素的总长度(包括body元素自身的padding)</p>
<p>总的来说，就是判断滚动的距离 + 视窗的高度是否大于等于 body的总高度</p>
</li>
</ul>
</li>
<li><p>下拉刷新实现思路</p>
<ul>
<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>
<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>
<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li>
</ul>
</li>
<li><p>如何减少回流和重绘</p>
<ol>
<li>有增删改查的表单避免使用table布局，table中每个元素大小以及内容的改动都会导致table的重新计算</li>
</ol>
</li>
<li><p>对于动画尽量设置成脱离文档流，设置为<code>position: fixed / absloute</code>，减少对其他元素的影响</p>
<ol start="3">
<li>对于DOM操作尽量一次完成</li>
</ol>
</li>
<li><p>referer和origin区别</p>
<ul>
<li>referer在所有情况下都会携带，origin只有在跨域请求的时候会有</li>
<li>origin是为了跨域涉及，只包含有协议、域名和端口，referer还包括路径和参数</li>
</ul>
</li>
<li><p>GET和POST区别</p>
<ol>
<li>GET相比POST不安全（对于浏览器层面，传输中如果是HTTPS都是安全的），因为参数直接暴露在URL上，所以不能用来传递敏感信息，如密码等。</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
<li>GET只接收ASCII字符，POST没有限制</li>
<li>GET请求有长度限制，POST没有（注意HTTP协议本身没有对Body和URL的长度限制，大多数浏览器有限制）</li>
<li>GET请求会被浏览器主动缓存，POST不会</li>
<li>GET请求中，浏览器会把数据直接发出去，而POST请求中浏览器先发送header，服务器响应100 continue，浏览器再发送data</li>
</ol>
</li>
<li><p>WebSocket</p>
<pre><code> Upgrade: websocket，过程中服务端向客服端发送一个密钥，然后服务器对密钥进行摘要计算以后再返回一个`Sec-WebSocket-Key`
</code></pre>
<p> 相比HTTP协议的优点：</p>
<ol>
<li>网络传输中开销更小，数据包的header更小，http每次请求都要携带完整header</li>
<li>实时性强，HTTP请求每次都要等待客户端发起请求服务端才能响应，更适合于网页游戏、实时更新的场景</li>
<li>有连接，</li>
<li>压缩效果更好，传输过程中会转换成二进制帧</li>
</ol>
</li>
<li><p>nodejs中process</p>
<p> process对象是node环境中的一个全局变量，提供了有关当前nodejs进程的信息并对其进行控制。</p>
<ul>
<li>process.env ： 环境变量，例如通过<code>process.env.NODE_ENV</code>获取不同环境项目配置信息</li>
<li>process.pid: 获取当前进程id   ppid 获取当前进程的父进程的id</li>
<li>process.cwd() 工作目录</li>
<li>process.argv：执行node命令时候传入的参数</li>
<li>process.nextTick()：在下一个时间轮询的时间点上执行（和setTimeout 0的区别在于setTimeout中的任务是宏任务，会将任务放到宏任务队列上，不确定什么时候才执行）</li>
</ul>
</li>
<li><p>nodejs中的fs</p>
<p> fs（filesystem），该模块提供本地文件的读写能力，所有与文件的操作都是通过<code>fs</code>核心模块实现</p>
</li>
<li><p>Node中buffer和stream</p>
<p> buffer是在用于在处理I/O的时候需要用到处理二进制数据流，为了提高node的并发性能，在内存中开辟一段区域，在操作数据库、文件系统等情况的时候先将二进制数据流写入到指定的区域，然后对应的文件处理好之后再通知node进行下一步的操作。</p>
<p> stream也是处理数据传输的手段，大文件中不是一次性将整个文件读入内存，<strong>而是分块逐块读取数据</strong>，其中分块中就用到了buffer（以buffer为单位），使用stream可以封装文件写入读取的过程，不需要关心内部的操作，只需要关注输入和输出即可，比如<code>babel</code>工具将es6代码转换为es5代码就用到了stream</p>
</li>
<li><p>node中EventEmitter</p>
<p> <code>EventEmitter</code> 在node中是一个非常重要的模块， <code>Node</code>采用了事件驱动机制，而<code>EventEmitter</code>就是<code>Node</code>实现事件驱动的基础。node中各个模块之所以可以绑定 / 触发监听器来实现异步操作，其功能就是来自继承的<code>EventEmitter</code>模块</p>
<p> 一个事件对应的对象都是events.EventEmitter类的实例，以此实现观察者模式，其中on方法注册一个事件监听，removeListener方法移除一个事件。</p>
</li>
<li><p>v8事件循环和node事件循环的区别</p>
</li>
<li><p>node进程的性能如何监控和优化</p>
<ol>
<li>查看内存情况，通过os模块的freememI()方法和totalmem()方法来查看系统的内存情况，通过process.memoryUsage()方法来查看node内存的占用以及分配情况。代码中要注意有没有内存泄露的情况</li>
<li>妥善使用Stream来处理I/O</li>
<li>项目的node版本是否可以升级</li>
<li>内存优化：<ul>
<li>考虑采用对象池的机制</li>
<li>频繁使用到的数据做缓存，如vue中的computed计算属性1</li>
</ul>
</li>
</ol>
</li>
<li><p>vue 响应式</p>
<p>所谓的响应式是指，在MVVM框架中，Model中的数据会显示到View中，如果Model的数据变更的话，可以动态的影响View之上对应的数据，Vue框架的响应式的实现原理的核心在于<strong>数据劫持</strong>，就是属性的<strong>setter</strong>中拦截到要进行的赋值操作，在此同时根据修改的数据来<strong>更新视图</strong>以及<strong>更新其他依赖</strong>于本属性的数据。每个属性对应都有一个<strong>dep数组</strong>，里面存放着所有<strong>依赖于自己</strong>（比如引用了自己或者通过自己的值来计算它的值）这个属性的watcher(<strong>watcher</strong>就是一个监听器，比如a依赖于b，a就生成一个watcher来监听b的变化)，自己这个值修改的时候，会<strong>通知dep中所有的watcher</strong>自己已经修改过了，让他们来动态的更新值。以此就实现了响应式数据。</p>
<ul>
<li>vue2中通过<code>Object.defineProperty</code>来设置属性的setter和getter。这种方法存在几个缺点：1. 无法动态的监听对象新增和的属性和删除属性，vue2中的解决办法是vue.set和vue.delete这两个api 2. 深度监听需要递归的遍历对象，对象如果是比较深层的，会比较耗时 3. 无法原生监听数组的更新（处理办法是vue2重写了数组的原型链，有七个方法可以响应式更新，分别是push pop shift unshift splice sort reverse（通过重写Array原型上的对应的方法，在原基础之上增加了响应式监听），直接通过下标更改是无法响应式更新的，另外还有$set和$remove  api可以改变数组）。</li>
<li>vue3中通过ES6语法中的Proxy来拦截对象中任意属性的变化，原生包括监听属性的读写、增加和删除，配合Reflect反射对源对象的属性进行操作。Proxy代理的是整个对象，整个对象任意属性的增删改查都会触发Proxy的回调函数。Reflect的作用：1. 绑定执行时候的this指向 2. Reflect可以让程序更加稳健，不需要一堆try catch去判断</li>
</ul>
</li>
<li><p>为什么用Proxy代替DefineProperty</p>
<ul>
<li>asd</li>
<li>注意在Proxy中的getter默认可以进行深度监听</li>
<li>defineProperty在递归的时候就要递归的进行监听，Proxy机制配合Reflect，在具体调用的时候再递归</li>
</ul>
</li>
<li><p>依赖收集：</p>
<p>依赖收集是指在vue一个组件初始化的过程中，对于响应式的数据，会将所有依赖他的watcher（watcher是为了实现跟别的数据同步更改等）整理起来，实现是每一个对象都有一个dep数组，这个数组中存放了所有依赖于它的watcher。然后在自己修改的时候（setter里面）会通知dep中所有的watcher，告诉对应的对象自己已经更改了属性。</p>
</li>
<li><p>patch</p>
<p>patch是Vue中DOM的更新策略，在我们进行了数据修改之后，会生成一个新的VNode，这时候与旧的VNode比较的过程就叫做patch，patch会用diff算法来比较VNode，最终根据diff算法得到的前后差异来真实DOM</p>
</li>
<li><p>v-for和v-if为什么不能同时用</p>
<p> 在官方文档里面不推荐v-for和v-if同时使用</p>
<ul>
<li>vue2中，v-for的优先级是高于v-if的，如果有这种情况：在一个很长的列表中，只有很少几项符合我们v-if的条件，它会先执行循环，再判断条件，相当于有很多无用的操作</li>
<li>有这种需求的话，一般可以先在js代码中对列表进行一个过滤。</li>
</ul>
</li>
<li><p>vue中key的作用</p>
<ul>
<li>指定key是为了避开diff算法默认的“就地复用”的策略，diff中可以通过a.key === b.key这样来判断两个元素是否相同</li>
<li>在v-if中指定key是为了避开复用同类型DOM元素，比如有两个输入框在动态切换，如果不指定v-if就可能出现切换的时候复用了另一个输入框组件，有可能看到另一个输入框保留的信息。如果指定了v-if，在patch过程中diff算法就知道这是两个不同的元素不能共用</li>
<li>在v-for更新已经渲染过的元素列表的时候，diff算法默认是“就地复用”的策略，是根据元素的顺序直接排下来复用，不会移动DOM元素来重新排列数据项，所以要指定key，对于每个key，diff算法就可以高效的通过key知道哪些可以复用，该用什么顺序。</li>
<li>使用key可以让diff算法对比的更快速，因为key是唯一的，底层是哈希表存储的，搜索复杂度为常数级别。</li>
</ul>
</li>
<li><p>vue computed如何实现缓存</p>
<p> computed是基于响应式依赖进行缓存的，只有当相关的响应式依赖发生改变的时候，才会重新求值，如果以来没有改变而访问内部的getter()，则会立即返回之前计算的结果，并不会重新执行函数。</p>
<p> 原理：首先对computed属性实现响应式处理，和普通data属性一样，依赖于哪个值，就创建一个watcher放到对方的dep依赖收集中，computed属性中有一个dirty标志位，true代表为脏数据需要重新计算，false不用重新计算，直接返回保存的之前的计算结果。它的getter中首先判断dirty属性然后。。，在watcher收到依赖变更的通知的时候，会把dirty修改为true，然后重新计算结果之后会把dirty再置为false</p>
</li>
<li><p><strong>diff算法的优化策略</strong>：四种命中查找，四个指针</p>
<ol>
<li>旧前与新前（先比开头，后插入和删除节点的这种情况）</li>
<li>旧后与新后（比结尾，前插入或删除的情况）</li>
<li>旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）</li>
<li>旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</li>
</ol>
</li>
<li><p>虚拟DOM理解</p>
<p> ​        虚拟DOM本质上是一个JavaScript对象，是为了提高操作DOM的效率而设计的，在原生DOM编程中，修改了数据以后让数据显示到页面上的方法都是直接操作DOM，由于操作DOM的开销很大，这样的话在编程中就要格外注意优化DOM操作，比如尽量减少操作的频率等，在Vue或者React框架里面使用虚拟DOM的话，数据修改之后并不是直接操作DOM，而是修改虚拟DOM，由于虚拟DOM就是在内存中的JS对象，所以操作起来效率很高，等一系列对虚拟DOM操作结束之后，虚拟DOM才会转换成真实DOM，渲染到页面上。</p>
<p> ​        还有就是可以保证组件的独立性，不同的虚拟DOM是不会相互影响的，减少组件之间的耦合</p>
</li>
<li><p>Vue组件间通信</p>
<ol>
<li>props / $emit</li>
<li>event bus</li>
<li>ref</li>
<li>$parent $root</li>
<li>Vuex</li>
<li>Provide / inject</li>
</ol>
</li>
<li><p>Vuex底层原理</p>
<p>Vuex其实就是一个全局单例的组件，暴露出接口来让对这个全局的单例组件内部的状态进行修改，再加上Vue本身的数据响应式这个特性，就可以实现全局的数据响应式存储和依赖。</p>
</li>
<li><p>$nextTick()怎么实现的</p>
<p>Vue.$nextTick()就是等到组件对应的DOM更新完之后再执行，Vue开启一个异步更新的队列，由于虚拟DOM的机制，数据发生变化之后，vue并<strong>不会立刻更新DOM</strong>，而是将修改数据的操作放到了一个<strong>异步操作队列</strong>中，如果我们一直<strong>修改相同的数据</strong>，异步操作队列还会<strong>进行去重</strong>，等待同一个事件循环中所有数据完成变化之后，会将队列中的事件拿来进行处理，进行DOM的更新。</p>
</li>
<li><p>Composition API和Mixin的区别</p>
<ol>
<li>不清晰的数据来源：如果使用了多个mixin，数据来源于哪个mixin就不清晰，而组合式API通过ref + 解构模式可以让属性的来源清晰</li>
<li>命令空间冲突，在组合式API中可以修改变量的别名来避免冲突。</li>
<li></li>
</ol>
</li>
<li><p>vue provide   inject</p>
<p>这两个API是为了让组件之间通信而设置的，一般来说是祖先节点中通过provide来提供一个变量，然后子孙节点通过inject来注入属性（祖先节点给子孙节点传数据），就是跨层级节点之间建立了一种主动提供和依赖注入的关系。还有很多可以用来代替的方法，比如设置一个EventBus，就是通过一个空的Vue实例来作为中央事件总线，用来触发事件和监听事件。还有Vuex这种全局的状态管理工具</p>
</li>
<li><p>Vue2和Vue3的区别（Vue2存在哪些问题）</p>
<ol>
<li>响应式的区别</li>
<li>重构了虚拟DOM</li>
</ol>
</li>
<li><p>Vue-Router路由模式</p>
<ol>
<li><p>hash模式，从表现上来说是在URL中通过#字符后面的字符来做为路由路径，如<code>http://example.com/#/user?id=123</code>其中/user就是路径，它是作为http请求里的参数存在的，和query参数一样，会被浏览器解析成参数，而http请求路径是不变的，所以每次改变hash值的话不会重新请求加载页面。vue-router实例通过监听hashChange事件来完成路由的跳转，内部也用到了html的锚点来实现</p>
</li>
<li><p>hitstory模式，history模式是通过H5的Histroy API来实现的，如果用history模式的话，URL中就不再使用hash了，请求路径都是真实的url地址，每一个不同路径的请求都会通过http请求发送到服务端，比如同一个页面中，如果浏览器刷新页面的话，hash模式中不会再向服务器发送请求，而history模式中就会发出请求重新刷新页面。在前进和后退操作中是用了History的API pushState()和relplaceState()方法来完成跳转，不用重新加载页面</p>
</li>
<li><p>abstract模式，是为了支持在非浏览器环境下使用的，所以不依靠浏览器的URL支持，需要router内部自己完成路由跳转，而不是借助于浏览器实现</p>
</li>
</ol>
</li>
<li><p>git </p>
<ol>
<li><p>revert和reset区别</p>
<p>revert是提交一次撤销，之前的commit结果都还在，rebase是硬性的取消，将之前的commit都删除掉。（revert的HEAD是向前移动，reset的HEAD是向后移动）</p>
</li>
</ol>
</li>
<li><p>进程和线程和协程</p>
<ul>
<li>进程是对动态运行的计算机程序的抽象，是系统分配资源的最小单位，线程是调度的最小单位</li>
<li>进程因为拥有独立的代码和数据空间，程序之间的切换会有比较大的开销，线程只有少数的资源（运行栈和程序计数器），所以线程的切换开销比进程小得多</li>
<li>同一个进程中的线程之间可以共享该进程的资源，进程间通信需要借助一定的手段，（IPC: ）</li>
<li>线程要依赖进程运行</li>
<li>协程是用户级别的线程，本质上是在用户态实现线程管理，把一个线程抽象成多个协程，调度协程不需要操作系统介入，操作系统也不知道有协程的存在，在高I/O场景中，可以减少频繁使用系统调用来切换线程的开销。</li>
</ul>
</li>
<li><p>孤儿进程和僵尸进程</p>
<ul>
<li><p>僵尸进程：子进程结束了，但是父进程没有对其进行资源回收，父进程中有其对应的task_struct，保存了进程的pid、退出码以及一些统计信息等（linux中用ps命令查看，z开头的就是僵尸进程，kill -9 不能直接杀死僵尸进程）</p>
<p>解决方案：1. wait  2. signal来进行异步通知</p>
</li>
<li><p>孤儿进程：在回收僵尸进程之前，这个父进程结束了，僵尸进程不会直接消失，而是变成孤儿进程，被init进程接管回收</p>
</li>
</ul>
</li>
<li><p>TypeScript高级类型</p>
<ul>
<li>交叉类型， 通过&amp; 将多个类型合并成一个类型，包含了所需的所有类型的特性，本质上是一种取并集的操作</li>
<li>联合类型，通过 | 相连，表示多个类型中取并且最多取一个</li>
<li>类型别名  type</li>
<li>类型索引 <code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</li>
<li>条件类型 和三元表达式一致，例如<code>T extends U ? X : Y</code></li>
</ul>
</li>
<li><p>TypeScript中的装饰器</p>
<p> TypeScript中的装饰器和JavaScript中的装饰器类似，本质上是把被装饰的函数或对象传入一个函数中，这个函数叫做装饰器，装饰器中可以对传入的被装饰者进行一系列的操作，本质上是一个Object.defineProperty的语法糖，引入的目的是为了让开发过程中写的代码更加的简洁，逻辑清晰方便后期维护（可以不改变原有代码的基础之上，对原来的功能进行扩展）。TS中可以装饰函数、参数、对象、getter。多个装饰器应用于一个声明上的话，是从下到上依次处理</p>
</li>
<li><p>TypeScript编写Vue</p>
</li>
<li><p>JavaScript中的立即执行函数有什么作用</p>
</li>
<li><p>小程序生命周期</p>
<ul>
<li>打开小程序：(App)onLaunch –&gt; (App)onShow –&gt; (Pages)onLoad –&gt; (Pages)onShow –&gt; (pages)onRead</li>
<li>进入下一个页面：(Pages)onHide –&gt; (Next)onLoad –&gt; (Next)onShow –&gt; (Next)onReady</li>
<li>返回上一个页面：(curr)onUnload –&gt; (pre)onShow</li>
</ul>
</li>
<li><p>小程序路由</p>
<ul>
<li>wx.navigateTo(Object)    保留当前页面，跳转到应用内某个非TabBar页面，navigateBack可以返回，返回的时候页面关闭（新页面入栈）</li>
<li>wx.redirectTo(Object)     关闭当前页面跳转（当前页面出栈，新页面入栈）</li>
<li>wx.switchTab(Object)      跳转到tabBar页面，并关闭其他所有非tabBar页面（全部出栈，只留下新的Tab页面）</li>
<li>wx.reLaunch(Object)       关闭所有的页面，打开到指定的页面，返回的时候跳转到首页（页面全部出栈，只留下新的页面）</li>
<li>wx.navigateBack(Object) 到指定的栈</li>
</ul>
</li>
<li><p>小程序首屏渲染优化</p>
<ol>
<li>上传代码的时候通过ide压缩代码上传</li>
<li>减少不必要的http请求，有的数据可以使用本地缓存</li>
<li>提前生成骨架屏</li>
<li>多次setData合并成一次</li>
<li> 非动态的数据不要setData</li>
<li>分包加载</li>
</ol>
</li>
<li><p>小程序运行原理</p>
<p>双线程模型，小程序和浏览器不一样，浏览器中每一个页面就是一个进程，该进程之下有不同的线程，其中主要的有js解释引擎和UI线程，它们虽然是两个线程，但是实际上是互斥执行的，js执行的时候会阻塞UI渲染如果加载的时间长就会有页面卡住的现象，之所以这么设计是因为JS可以操作DOM，设计为互斥的的话可以解决二者同步问题。而小程序底层设计是不允许直接操作DOM的，不需要像浏览器那样设计为互斥的，所以执行效率要高。</p>
<p>初始渲染逻辑：视图层开始做一些页面的初级准备，逻辑层开始创建页面对象，等逻辑层将页面数据发过来，页面开始渲染，此时逻辑层进入onLoad阶段，（可以在此时发送http请求等动态数据），等待页面渲染完毕之后，返回给逻辑层信号，逻辑层进入onReady阶段。</p>
</li>
<li><p>什么是设计模式</p>
<p>  设计模式是在为软件设计开发中针对于代码的可维护性、可复用性的解决方案，对于不同的场景需求，有多种设计模式，比如单例模式、工厂模式、装饰者模式等</p>
<ul>
<li>单例模式：保证一个类有且仅有一个对象，外部去访问的时候，只能访问到这一个对象，目的是保证状态的唯一性。比如在开发后台管理系统中，全局的用户设置，就适合用单例模式思想来做，在任何地方访问当前的用户设置都应该是一样的，修改一处别的地方也要受影响。Vuex就是基于单例模式做的一个应用        </li>
<li>工厂模式：工厂模式是用来创建对象的一种模式，不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就被叫做一个工厂，只要给工厂函数传入特定的参数，就会根据指定的参数来生成指定的对象。举例：在编程中，如果有一个A类，有很多的类都使用到了A类，在其他的类中实例化了A类的对象，此时，如果A类有接口上的修改，那么所有依赖于A类的类都需要在代码上进行具体的修改，非常的不方便。这种情况下，就适合将创建实例的这部分工作从A类中分离出来，也就是使用工厂方法来封装实例化A类的过程，由工厂函数统一的进行实例化。比如vue中虚拟DOM根据参数的不同创建不同的VNode</li>
<li>发布-订阅模式，如vue事件机制</li>
<li>观察者模式，如@装饰器用法，在不破坏原来代码的基础上对函数进行扩充功能，或者对对象添加属性</li>
<li>策略模式，策略模式指对象有某个行为，在不同的场景有不同的实现方案，</li>
</ul>
</li>
<li><p>Vue生命周期</p>
<ol>
<li>beforeCreate 在实例初始化之后，数据和方法被初始化之前</li>
<li>created 实例已经创建完成之后被调用，此时data methods computed watch等数据都可以正常访问，可以在此发送网络请求</li>
</ol>
</li>
<li><p>适配移动端</p>
<ol>
<li></li>
<li>解决方案：1. 通过css3媒体查询，@media来指定屏幕宽度为多少范围内的话应该用什么方案展示 2. css相对单位，rem，em是相对于上级元素的font-size的大小，rem是针对根元素的font-size的大小（如果根元素font-size是18px，那么1rem就是18px）3. 通过vw/vh单位来设置控件大小，1vw就是1/100 总宽度， 1vh就是1/100 总高度</li>
</ol>
</li>
<li><p>React生命周期</p>
<p> 16.4版本之后有三个阶段，</p>
<p> 其中初始阶段最重要的是<code>componentDidMount</code>，该阶段DOM已经创建完毕，通常获取数据都在这一步</p>
<p> 更新阶段最重要的是<code>componentDidUpdate</code>，该阶段组件已经更新完毕</p>
<p> 结束阶段最重要的是<code>componentWillUnmount</code>，该阶段在组件回收之前，可以做一些回收资源的操作</p>
</li>
<li><p>为什么React中组件构造器中必须有super()</p>
<p>React中自定义的组件都要继承自React.component，子类是没有自己上下文环境的，只能继承父类的this对象，然后再加入一些自己的东西。super函数就是将父类的环境继承给自己。同样这里有个问题就是在super()之前不能this.xx</p>
</li>
<li><p>React的setState</p>
<p>在React中存放组件自身的的动态数据用的是state，setState就是对state进行改动，由于React没有像Vue那样对数据做一个响应式处理，直接修改state的话，不会影响视图，在setState中修改数据可以让视图同步改变，原因是setState函数修改完state状态之后，还会重新执行render函数进行视图的更新。</p>
<p>setState函数在组件生命周期中是异步更新的，如果需要修改完数据之后执行一些操作，需要在setState第二个参数中传入一个回调函数。但是在原生DOM事件中，setState是同步执行的。（在微信小程序中setData也是同步的）</p>
<p><em>setState函数内部有一个批量更新策略，多次顺序setState会导致覆盖掉前面的</em></p>
</li>
<li><p>事件委托</p>
<p>事件委托是在DOM树中，多个子节点的事件可以统一交给他们的父节点或者祖先节点来完成，这样的话可以减小很多子节点的时候带来的重复的监听器开销，比如click事件，多个子节点可以全都交给父节点来监听，子节点触发以后由冒泡机制传播给父节点，父节点事件监听器判断到是来自于这个子节点的时候，给他执行相应的操作。</p>
<p>React的事件模型就用到了事件委托，给某一个组件绑定事件并不是直接绑定到对应的DOM节点上面，而是采用事件绑定到doucument这个顶级DOM上，在顶级DOM中统一处理。</p>
</li>
<li><p>React中组件间通信</p>
<ul>
<li>父组件向子组件 props</li>
<li>子组件向父组件，父组件向子组件传递一个函数，这个函数中绑定父组件的函数</li>
<li>redux全局状态管理</li>
</ul>
</li>
<li><p>npm install 发生了什么</p>
<p> <em>npm install 就是通过npm这个工具来安装依赖包，依赖包默认被安装到node_modules文件夹中。早期的npm安装是粗暴的直接按照package.json文件中依赖的层次结构来下载的，在之后3.X的版本中对此做了优化，将早期的嵌套结构改成扁平的结构</em></p>
<ul>
<li>首先检查.npmrc文件，优先级为项目级 / 用户级 / 全局 / npm内置</li>
<li>检查package-lock.json文件，这个文件中主要是通过锁定具体的版本号来确定一个依赖。如果有lock文件的话，检查和package.json文件是否冲突。</li>
<li>根据package.json构建依赖树，因为要下载的东西可能还会层层依赖别的东西，从逻辑上一层层的构建这个依赖树（这一步并没有真正的下载）</li>
<li>在缓存中查找依赖树中对应的包，_cached文件夹中保存着对应的缓存，如果存在缓存的话就直接解压到node_modules，如果不存在的话就从npm远程仓库中下载</li>
</ul>
</li>
<li><p>说一说yarn</p>
<p>yarn一开始提出的时候优势在于，当时npm还没有lock机制，不稳定不安全</p>
</li>
<li><p>Ajax ——<strong>XMLHttpRequest</strong></p>
<ol>
<li>Ajax就是用来发送异步请求的，像axios还有小程序的request等底层都是基于ajax做的</li>
<li>注意传输的过程用JSON库来转换对象和JSON字符串</li>
<li>手写流程：<ul>
<li>首先创建XMLHttpRequest实例，xhr</li>
<li>xhr.open</li>
<li>xhr.setRequestHeader</li>
<li>xhr.send</li>
<li>xhr.onreadystatechange（state=4）或者xhr.onLoad()（区别就在于onreadystatechange并不一定是成功，onLoad一定是）</li>
</ul>
</li>
</ol>
</li>
<li><p>babel原理</p>
<ul>
<li>首先经过词法分析（分解成一个个的最小单元）以及语法分析（通过一个个最小单元连接起来分析语法分析作用）生成AST抽象语法树，然后经过transform（就是对语法进行一些转换，具体的就是那些es6怎么去兼容es5），最后一个过程叫generate，也就是根据转换后的AST生成对应的代码。</li>
<li>配置文件中preset是一些plugin的合集，比如官方的有env、react、typescript等</li>
</ul>
</li>
<li><p>asd</p>
</li>
<li><p>asd</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">王晨昊</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/22/%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/">http://example.com/2023/02/22/%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">nccoder</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">编程技术</a><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="https://img1.baidu.com/it/u=896707904,4002445675&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/03/CSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.boxuegu.com%2Ffa4439b0c04e47829ca9fe1697347a8d.png&amp;refer=http%3A%2F%2Ffile.boxuegu.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650633227&amp;t=b06bd0b121a8aee58d8abd694dbc32da" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSS常见问题</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/14/DOM%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-6c272f6470a98eca718c2fd550bbd804_1440w.jpg&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1642560469&amp;t=804728af8b46edfb0980cddbacc95650" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DOM事件捕获和冒泡</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/29/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Cpython%E7%A8%8B%E5%BA%8F/" title="linux后台运行python程序"><img class="cover" src="https://img1.baidu.com/it/u=896707904,4002445675&fm=253&fmt=auto&app=138&f=PNG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-29</div><div class="title">linux后台运行python程序</div></div></a></div><div><a href="/2023/02/14/DOM%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/" title="DOM事件捕获和冒泡"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-6c272f6470a98eca718c2fd550bbd804_1440w.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642560469&t=804728af8b46edfb0980cddbacc95650" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-14</div><div class="title">DOM事件捕获和冒泡</div></div></a></div><div><a href="/2021/07/21/Django-ORM%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/" title="Django-ORM对数据库操作"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.boxuegu.com%2F03b52c2f26024e17be6e920fddeb1751.jpg&refer=http%3A%2F%2Ffile.boxuegu.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642560564&t=ce52dc99d94ff4ff2222ece9e99dc26a" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">Django-ORM对数据库操作</div></div></a></div><div><a href="/2021/07/21/Django%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%A4%BA%E6%8A%A5%E9%94%99AttributeError%20%EF%BC%9A/" title="Django迁移数据库表示报错的解决方案"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.boxuegu.com%2F03b52c2f26024e17be6e920fddeb1751.jpg&refer=http%3A%2F%2Ffile.boxuegu.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642560564&t=ce52dc99d94ff4ff2222ece9e99dc26a" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">Django迁移数据库表示报错的解决方案</div></div></a></div><div><a href="/2021/07/21/Restful%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="Restful微服务"><img class="cover" src="https://img0.baidu.com/it/u=3713120937,2168914409&fm=253&fmt=auto&app=138&f=JPEG?w=356&h=240" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">Restful微服务</div></div></a></div><div><a href="/2021/07/21/call,apply,bind%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/" title="call,apply,bind函数的区别"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F1331779-07ef0086026d0b9b.jpeg&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642560529&t=df5ebd32009def89c4dc10f1e9681edd" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">call,apply,bind函数的区别</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">王晨昊</div><div class="author-info__description">日常分享以及学习分享</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/jnuwangchenhao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/jnuwangchenhao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wangchenhao@stu2021.jnu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">和我一起学习吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">计算机原理综合笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%EF%BC%9A"><span class="toc-number">1.0.1.0.0.1.</span> <span class="toc-text">防御：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.0.1.0.0.2.</span> <span class="toc-text">存储型：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.0.1.0.0.3.</span> <span class="toc-text">反射型：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DOM%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.0.1.0.0.4.</span> <span class="toc-text">DOM型：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">1.0.1.0.0.5.</span> <span class="toc-text">解决方案：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.1.0.0.6.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记"><img src="https://img0.baidu.com/it/u=3530764155,2263060192&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记"/></a><div class="content"><a class="title" href="/2023/05/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记">算法笔记</a><time datetime="2023-05-11T03:08:33.000Z" title="发表于 2023-05-11 11:08:33">2023-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Confusion-Matrix%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/" title="机器学习-Confusion Matrix混淆矩阵"><img src="https://img0.baidu.com/it/u=3885357848,2008775213&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=900&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习-Confusion Matrix混淆矩阵"/></a><div class="content"><a class="title" href="/2023/03/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Confusion-Matrix%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/" title="机器学习-Confusion Matrix混淆矩阵">机器学习-Confusion Matrix混淆矩阵</a><time datetime="2023-03-25T07:23:58.000Z" title="发表于 2023-03-25 15:23:58">2023-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/03/CSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="CSS常见问题"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.boxuegu.com%2Ffa4439b0c04e47829ca9fe1697347a8d.png&amp;refer=http%3A%2F%2Ffile.boxuegu.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650633227&amp;t=b06bd0b121a8aee58d8abd694dbc32da" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS常见问题"/></a><div class="content"><a class="title" href="/2023/03/03/CSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="CSS常见问题">CSS常见问题</a><time datetime="2023-03-03T13:06:36.000Z" title="发表于 2023-03-03 21:06:36">2023-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/22/%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/" title="原理综合笔记"><img src="https://img1.baidu.com/it/u=896707904,4002445675&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="原理综合笔记"/></a><div class="content"><a class="title" href="/2023/02/22/%E5%8E%9F%E7%90%86%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/" title="原理综合笔记">原理综合笔记</a><time datetime="2023-02-22T03:37:20.000Z" title="发表于 2023-02-22 11:37:20">2023-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/14/DOM%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/" title="DOM事件捕获和冒泡"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-6c272f6470a98eca718c2fd550bbd804_1440w.jpg&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1642560469&amp;t=804728af8b46edfb0980cddbacc95650" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DOM事件捕获和冒泡"/></a><div class="content"><a class="title" href="/2023/02/14/DOM%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/" title="DOM事件捕获和冒泡">DOM事件捕获和冒泡</a><time datetime="2023-02-14T08:24:50.000Z" title="发表于 2023-02-14 16:24:50">2023-02-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 王晨昊</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">简单记录学习和生活</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,L,O,V,E,Y,O,U" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>